1.	Введите строку, состоящую из 2 цифр. Преобразуйте ее в целое и вещественное число. Выведите полученные 3 значения (строку, целое число, вещественное число) на экран в одной строке через запятую, затем пропустите строку и вновь выведите значения по одному на строке. Перед каждым значением выведите его тип.
Решение:


# Введите строку, состоящую из 2 цифр
input_string = input("Введите строку из 2 цифр: ")

# Преобразуйте строку в целое и вещественное число
integer_number = int(input_string)
float_number = float(input_string)

# Выведите значения через запятую на одной строке
print(f"Строка: {input_string}, Целое число: {integer_number}, Вещественное число: {float_number}\n")

# Выведите значения по одному на строке с указанием их типов
print(f"Тип строки: {type(input_string)}")
print(f"Значение строки: {input_string}\n")

print(f"Тип целого числа: {type(integer_number)}")
print(f"Значение целого числа: {integer_number}\n")

print(f"Тип вещественного числа: {type(float_number)}")
print(f"Значение вещественного числа: {float_number}")

2.	Для заданного четырехзначного числа выведите число, у которого цифры идут в обратном порядке, например, для числа 1234 ответ 4321.
Решение:
# Введите четырехзначное число
number = int(input("Введите четырехзначное число: "))

# Переведите число в строку и разверните его
reversed_number = int(str(number)[::-1])

# Выведите результат
print("Число с обратным порядком цифр:", reversed_number)

3.	По номеру года определите, является ли данный год високосным. (год является високосным, если его номер кратен 4, но не кратен 100, а также если он кратен 400).
Решение:
# Введите год
year = int(input("Введите год: "))

# Проверьте, является ли год високосным
if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0):
    print(f"{year} год - високосный")
else:
    print(f"{year} год - не високосный")

4.	Строка содержит фамилию, имя и отчество, записанные через пробелы. Например « Иванов Иван Иванович». Для этой строки получите строки вида «Иванов И.И.» и «И.И. Иванов»
Решение:
# Введите строку с фамилией, именем и отчеством
full_name = input("Введите фамилию, имя и отчество через пробел: ")

# Разделите строку на отдельные части (фамилия, имя, отчество)
parts = full_name.split()

# Проверьте, что в строке есть как минимум 3 части (фамилия, имя, отчество)
if len(parts) >= 3:
    # Получите первую букву имени и отчества и добавьте точку
    initials = f"{parts[1][0]}.{parts[2][0]}."

    # Создайте строки вида "Иванов И.И." и "И.И. Иванов"
    full_format = f"{parts[0]} {initials}"
    reverse_format = f"{initials} {parts[0]}"

    # Выведите полученные строки
    print(full_format)
    print(reverse_format)
else:
    print("Введите корректные данные с фамилией, именем и отчеством.")

5.	Вычислите значение выражения, которое состоит из целых чисел и знаков «+» и «-». Выражение вводится как символьная строка.
Решение:
# Введите выражение в виде символьной строки
expression = input("Введите выражение (пример: 2+3-1): ")

try:
    # Используйте eval() для вычисления значения выражения
    result = eval(expression)

    # Выведите результат
    print("Результат выражения:", result)
except:
    print("Ошибка: Неправильный формат выражения.")

6.	Дана строка, состоящая из слов, разделенных пробелами. В этой строке:
•	Удалите все лишние пробелы (Удалите в начале и в конце. Между словами  надо оставить ровно один пробел);
•	В первых двух словах поменяйте регистр символов (строчные сделать прописными, прописные – строчными);
•	Определите, сколько в строке слов.
Решение:

# Введите строку с словами
input_string = input("Введите строку с 2 словами: ")

# Удалите лишние пробелы (в начале и в конце)
cleaned_string = input_string.strip()

# Замените регистр первых двух слов
words = cleaned_string.split()
if len(words) >= 2:
    words[0] = words[0].swapcase()  # Первое слово
    words[1] = words[1].swapcase()  # Второе слово

# Сколько слов в строке
word_count = len(words)

# Объедините слова обратно в строку с одним пробелом между ними
result_string = ' '.join(words)

# Выведите результаты
print("Строка с удаленными лишними пробелами и измененным регистром:")
print(result_string)
print("Количество слов в строке:", word_count)

7.	Имеются 2 списка целых чисел, упорядоченные по возрастанию. Получите новый список, содержащий все элементы исходных списков, в котором элементы также упорядочены в порядке возрастания, не используя сортировку.
Решение:

# Исходные упорядоченные списки
list1 = [1, 3, 5, 7, 9]
list2 = [2, 4, 6, 8, 10]

# Создаем новый пустой список для объединения элементов
result_list = []

# Индексы для обхода списков
index1 = 0
index2 = 0

# Обходим оба списка и добавляем элементы в результат
while index1 < len(list1) and index2 < len(list2):
    if list1[index1] < list2[index2]:
        result_list.append(list1[index1])
        index1 += 1
    else:
        result_list.append(list2[index2])
        index2 += 1

# Если остались элементы в одном из списков, добавляем их
result_list.extend(list1[index1:])
result_list.extend(list2[index2:])

# Выводим результат
print(result_list)

8.	Пользователь вводит произвольную строку в виде нескольких слов. Надо составить список, в котором слова находятся в лексикографическом порядке по возрастанию. Затем надо составить
строку, в которой все слова списка, сформированного ранее, перечисляются через пробел.
Словом в строке надо считать подстроку, ограниченную пробелами или началом и концом строки.
Решение:
# Получите строку от пользователя
input_string = input("Введите строку с несколькими словами: ")

# Разделите строку на слова
words = input_string.split()

# Отсортируйте слова в лексикографическом порядке
sorted_words = sorted(words)

# Объедините слова в строку через пробел
result_string = ' '.join(sorted_words)

# Выведите отсортированную строку
print("Слова в лексикографическом порядке:", result_string)

9.	Реализуйте умножение двух матриц, записанных как список списков (без использования специализированных библиотек). При этом надо проверить, что размерности матриц таковы, что их можно умножать. Если не, то надо вывести сообщение об ошибке.
Решение:
# Функция для умножения двух матриц
def multiply_matrices(matrix1, matrix2):
    rows1 = len(matrix1)
    cols1 = len(matrix1[0])
    rows2 = len(matrix2)
    cols2 = len(matrix2[0])

    # Проверка, можно ли умножить матрицы
    if cols1 != rows2:
        print("Ошибка: Неверные размерности матриц для умножения.")
        return None

    # Инициализация результирующей матрицы нулями
    result_matrix = [[0 for _ in range(cols2)] for _ in range(rows1)]

    # Умножение матриц
    for i in range(rows1):
        for j in range(cols2):
            for k in range(cols1):
                result_matrix[i][j] += matrix1[i][k] * matrix2[k][j]

    return result_matrix

# Примеры матриц для умножения
matrix1 = [[1, 2, 3], [4, 5, 6]]
matrix2 = [[7, 8], [9, 10], [11, 12]]

# Умножаем матрицы
result = multiply_matrices(matrix1, matrix2)

# Вывод результата
if result:
    print("Результат умножения матриц:")
    for row in result:
        print(row)

10.	Надо реализовать игру "Волки  и овцы" - https://ru.wikipedia.org/wiki/%D0%92%D0%BE%D0%BB%D0%BA_%D0%B8_%D0%BE%D0%B2%D1%86%D1%8B. Поле задается в виде матрицы 8 х 8 (в виде соответствующего списка списков). Каждый ход кодируется заданием двух полей - того, на котором находится фишка и того, на которое она перемещается. Алгоритм должен сам определить, когда какая-то из сторон выиграла.

11.	Имеется строка с названиями товаров вида «яблоки, груши, яблоки, киви, сливы, киви». Товары перечислены через запятую, товары могут повторяться, после запятой может стоять пробел. Выведите таблицу из двух колонок. В левой колонке - название товара, в правой - количество названий этого товара, встречающихся в строке. Таблицу надо упорядочить по уменьшению количества названий товара в строке.
Решение:
# Исходная строка с названиями товаров
input_string = "яблоки, груши, яблоки, киви, сливы, киви"

# Разделите строку на названия товаров, удаляя пробелы после запятых
product_names = [product.strip() for product in input_string.split(',')]

# Создайте словарь для подсчета количества каждого товара
product_count = {}
for product in product_names:
    if product in product_count:
        product_count[product] += 1
    else:
        product_count[product] = 1

# Отсортируйте словарь по убыванию количества товаров
sorted_product_count = sorted(product_count.items(), key=lambda x: x[1], reverse=True)

# Выведите таблицу
print("{:<15} {:<10}".format("Название", "Количество"))
print("-" * 25)
for product, count in sorted_product_count:
    print("{:<15} {:<10}".format(product, count))

12.	В строке закодировано сообщение при помощи азбуки Морзе (без знаков препинания - закодированы только буквы английского алфавита и цифры) - https://ru.wikipedia.org/wiki/%D0%90%D0%B7%D0%B1%D1%83%D0%BA%D0%B0_%D0%9C%D0%BE%D1%80%D0%B7%D0%B5 . Тире кодируется дефисом, а точка - точкой. Между буквами ставится пробел.
Программа должна по строке с кодом Морзе составить соответствующую строку на английском языке и вывести ее на печать.
Решение:
# Словарь с кодами букв и цифр в азбуке Морзе
morse_code_dict = {
    'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.', 'G': '--.', 'H': '....',
    'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..', 'M': '--', 'N': '-.', 'O': '---', 'P': '.--.',
    'Q': '--.-', 'R': '.-.', 'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-',
    'Y': '-.--', 'Z': '--..',
    '0': '-----', '1': '.----', '2': '..---', '3': '...--', '4': '....-', '5': '.....',
    '6': '-....', '7': '--...', '8': '---..', '9': '----.'
}

# Функция для декодирования строки из азбуки Морзе
def decode_morse_code(morse_code):
    words = morse_code.split(' ')
    decoded_message = ''
    for word in words:
        if word in morse_code_dict.values():
            decoded_message += list(morse_code_dict.keys())[list(morse_code_dict.values()).index(word)]
        else:
            decoded_message += ' '
    return decoded_message

# Входная строка с кодом Морзе
morse_code = "... --- -- . "

# Декодируем и выводим результат
decoded_message = decode_morse_code(morse_code)
print("Декодированное сообщение:", decoded_message)

13.	Создайте 2 списка из 5 случайных целых чисел от 1 до 10. Найдите симметрическую разность (https://ru.wikipedia.org/wiki/%D0%A1%D0%B8%D0%BC%D0%BC%D0%B5%D1%82%D1%80%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F_%D1%80%D0%B0%D0%B7%D0%BD%D0%BE%D1%81%D1%82%D1%8C) множеств, соответствующих спискам в выведете ее на печать.
Решение:
import random

# Создайте два списка случайных целых чисел от 1 до 10
list1 = [random.randint(1, 10) for _ in range(5)]
list2 = [random.randint(1, 10) for _ in range(5)]

# Найдите множества, соответствующие спискам
set1 = set(list1)
set2 = set(list2)

# Найдите симметрическую разность множеств
symmetric_difference = set1.symmetric_difference(set2)

# Выведите симметрическую разность на печать
print("Список 1:", list1)
print("Список 2:", list2)
print("Симметрическая разность множеств:", list(symmetric_difference))

14.	Из множества целых чисел от 1 до 100 (включительно) выделите в отдельное множество и выведите его на печать - числа, кратные либо 2, либо 3, но при этом не одновременно 2 и 3.
Решение:
# Создайте множество для хранения чисел, кратных 2 или 3 (но не обоим)
result_set = set()

# Переберите числа от 1 до 100
for number in range(1, 101):
    if (number % 2 == 0) != (number % 3 == 0):
        result_set.add(number)

# Выведите множество на печать
print("Числа, кратные 2 или 3, но не одновременно 2 и 3:", result_set)

15.	Введите целое число. Выведите его на экран и допишите к нему слова «рубль», «рубля» или «рублей» в зависимости от значения.
Ответ:
# Введите целое число
number = int(input("Введите целое число: "))

# Определите склонение слова "рубль"
if 11 <= number <= 19:
    word = "рублей"
else:
    last_digit = number % 10
    if last_digit == 1:
        word = "рубль"
    elif 2 <= last_digit <= 4:
        word = "рубля"
    else:
        word = "рублей"

# Выведите число и слово на экран
print(f"{number} {word}")

16.	Напишите программу, которая находит наибольший общий делитель двух целых чисел, используя алгоритм Евклида - https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%95%D0%B2%D0%BA%D0%BB%D0%B8%D0%B4%D0%B0
Решение:
# Функция для нахождения НОД с использованием алгоритма Евклида
def gcd_euclidean_algorithm(a, b):
    while b:
        a, b = b, a % b
    return a

# Введите два целых числа
num1 = int(input("Введите первое целое число: "))
num2 = int(input("Введите второе целое число: "))

# Найдите НОД и выведите его на экран
result = gcd_euclidean_algorithm(num1, num2)
print(f"Наибольший общий делитель {num1} и {num2} равен {result}")

17.	Выведите значение заданного целого числа от 0 до 1000 прописью. Например, «сто девяносто один» для числа 191, «одиннадцать» для числа 11.
Решение:
# Функция для преобразования числа в текстовое представление
def number_to_words(number):
    units = ["", "один", "два", "три", "четыре", "пять", "шесть", "семь", "восемь", "девять"]
    teens = ["", "одиннадцать", "двенадцать", "тринадцать", "четырнадцать", "пятнадцать", "шестнадцать", "семнадцать", "восемнадцать", "девятнадцать"]
    tens = ["", "десять", "двадцать", "тридцать", "сорок", "пятьдесят", "шестьдесят", "семьдесят", "восемьдесят", "девяносто"]
    hundreds = ["", "сто", "двести", "триста", "четыреста", "пятьсот", "шестьсот", "семьсот", "восемьсот", "девятьсот"]

    if 0 <= number <= 9:
        return units[number]
    elif 11 <= number <= 19:
        return teens[number - 10]
    elif 20 <= number <= 99:
        return tens[number // 10] + " " + units[number % 10]
    elif 100 <= number <= 999:
        return hundreds[number // 100] + " " + number_to_words(number % 100)
    elif number == 1000:
        return "тысяча"
    else:
        return "Число вне допустимого диапазона (0-1000)"

# Введите целое число от 0 до 1000
number = int(input("Введите целое число от 0 до 1000: "))

# Преобразуйте число в текст и выведите его на экран
if 0 <= number <= 1000:
    result = number_to_words(number)
    print(f"Число {number} прописью: {result}")
else:
    print("Число вне допустимого диапазона.")

18.	Имеется список названий месяцев: [‘января’, ‘февраля’, ‘марта’, ‘апреля’, ’мая’, ‘июня’, ‘июля’, ‘августа’, ‘сентября’, ‘октября’, ‘ноября’, ‘декабря’]. Создайте по этому списку словарь, в котором название месяца будет ключом, а номер месяца (от 1 до 12) – значением. Используя полученный словарь преобразуйте строку с датой вида «1 января 2021» в строку «1.01.2021»
Решение:
# Список названий месяцев
months = ['января', 'февраля', 'марта', 'апреля', 'мая', 'июня', 'июля', 'августа', 'сентября', 'октября', 'ноября', 'декабря']

# Создайте словарь, сопоставляющий названия месяцев с их номерами
month_dict = {month: str(index + 1).zfill(2) for index, month in enumerate(months)}

# Введите строку с датой
date_string = input("Введите дату в формате '1 января 2021': ")

# Разбейте строку на компоненты
day, month_name, year = date_string.split()

# Получите номер месяца из словаря
month_number = month_dict[month_name]

# Сформируйте и выведите новую строку в формате "1.01.2021"
new_date_string = f"{day}.{month_number}.{year}"
print("Преобразованная дата:", new_date_string)

19.	Реализовать функции для выполнения четырех арифметических операций (сложение, вычитание, умножение, деление), преобразующих целые числа в целое число (т.е если результат операции оказался дробным, то надо преобразовать его в целое по математическому правилу округления). Для выполнения задания надо создать словарь с функциями и соответствующими им символами операций.
В программе надо для двух конкретных чисел выполнить выбранную пользователем (по введенному пользователем имени) арифметическую операцию.
Решение:
# Функция для сложения
def add(x, y):
    return x + y

# Функция для вычитания
def subtract(x, y):
    return x - y

# Функция для умножения
def multiply(x, y):
    return x * y

# Функция для деления
def divide(x, y):
    if y == 0:
        return "Ошибка: деление на ноль"
    return x // y

# Создайте словарь с операциями
operations = {
    '+': add,
    '-': subtract,
    '*': multiply,
    '/': divide
}

# Запросите у пользователя ввод чисел и операции
num1 = int(input("Введите первое число: "))
num2 = int(input("Введите второе число: "))
operation = input("Выберите операцию (+, -, *, /): ")

# Проверьте, что операция существует в словаре
if operation in operations:
    # Вызовите соответствующую функцию и выведите результат
    result = operations[operation](num1, num2)
    print(f"Результат: {result}")
else:
    print("Неверная операция")

20.	Реализовать функцию умножения, принимающую неограниченное количество значений.
Написать примеры использования этой функции с аргументами:
•	(15, 10 ,5)
•	(3, 1)
•	[2, 35, 55]
•	(5, 10 ,15, 20)

Решение:
# Функция умножения, принимающая неограниченное количество аргументов
def multiply(*args):
    result = 1
    for num in args:
        result *= num
    return result

# Примеры использования функции с разными наборами аргументов
print("Умножение (15, 10, 5):", multiply(15, 10, 5))
print("Умножение (3, 1):", multiply(3, 1))
print("Умножение [2, 35, 55]:", multiply(2, 35, 55))
print("Умножение (5, 10, 15, 20):", multiply(5, 10, 15, 20))

21.	 Дана дробь n / m , n и m - натуральные числа. Напишите 2 функции, которые сокращают эту дробь, то есть находят числа p и q такие, что    n / m = p / q , и дробь p / q — несократимая:
1.	Случай 1- аргументами функции являются числа n, m, функция возвращает кортеж (p, q);
2.	Случай2 аргументом функции является список [n, m], функция не возвращает значения, а изменяет этот список на [p, q].
Решение:
1 случай
import math

def reduce_fraction(n, m):
    gcd = math.gcd(n, m)
    p = n // gcd
    q = m // gcd
    return (p, q)

# Пример использования
n = 12
m = 18
reduced_fraction = reduce_fraction(n, m)
print(f"Исходная дробь: {n}/{m}")
print(f"Сокращенная дробь: {reduced_fraction[0]}/{reduced_fraction[1]}")

2случай 
import math

def reduce_fraction_inplace(fraction_list):
    n, m = fraction_list
    gcd = math.gcd(n, m)
    fraction_list[0] = n // gcd
    fraction_list[1] = m // gcd

# Пример использования
fraction = [12, 18]
print(f"Исходная дробь: {fraction[0]}/{fraction[1]}")
reduce_fraction_inplace(fraction)
print(f"Сокращенная дробь: {fraction[0]}/{fraction[1]}")

22.	Написать функцию, которая преобразует целое число (от 0 до 1000) из текстового представления на русском языке в число типа int. И сообщает об ошибках (выводит на экран описание типа ошибки и возвращает чило -1).

Пример: to_int('тридцать три')    ->   33

Пример: to_int("сто сорок тридцать два сто")    ->  -1 Вывод: тридцать - некорректное расположение в числе.
Решение:
def to_int(text):
    # Создадим словарь для соответствия числительных и их числовых значений
    numbers_dict = {
        'ноль': 0, 'один': 1, 'два': 2, 'три': 3, 'четыре': 4, 'пять': 5, 'шесть': 6, 'семь': 7, 'восемь': 8, 'девять': 9,
        'десять': 10, 'одиннадцать': 11, 'двенадцать': 12, 'тринадцать': 13, 'четырнадцать': 14, 'пятнадцать': 15,
        'шестнадцать': 16, 'семнадцать': 17, 'восемнадцать': 18, 'девятнадцать': 19,
        'двадцать': 20, 'тридцать': 30, 'сорок': 40, 'пятьдесят': 50, 'шестьдесят': 60, 'семьдесят': 70, 'восемьдесят': 80, 'девяносто': 90,
        'сто': 100, 'двести': 200, 'триста': 300, 'четыреста': 400, 'пятьсот': 500, 'шестьсот': 600, 'семьсот': 700, 'восемьсот': 800, 'девятьсот': 900,
        'тысяча': 1000
    }

    # Разбиваем строку на слова
    words = text.split()

    # Инициализируем переменные для хранения результата и текущего числа
    result = 0
    current_number = 0

    # Проходим по словам в строке
    for word in words:
        if word in numbers_dict:
            # Если слово есть в словаре, добавляем его числовое значение к текущему числу
            current_number += numbers_dict[word]
        else:
            # Если слова нет в словаре, это может быть ошибка
            print(f'Ошибка: "{word}" - некорректное слово в числе.')
            return -1

    # Возвращаем сумму чисел, образующих текстовое представление числа
    return current_number

# Примеры использования функции
print(to_int('тридцать три'))  # Вывод: 33
print(to_int("сто сорок тридцать два сто"))  # Вывод: Ошибка: "сорок" - некорректное слово в числе. -1

23.	Элементами матрицы являются случайные положительные целые числа из заданного диапазона. Число строк и столбцов матрицы задается с клавиатуры. Написать функцию подсчета среднего арифметического элементов над главной диагональю и
количество четных элементов под ней. Если матрица не является квадратной, должно генерироваться исключение
Решение:
import random

# Функция для создания матрицы
def create_matrix(rows, cols, min_value, max_value):
    matrix = []
    for _ in range(rows):
        row = [random.randint(min_value, max_value) for _ in range(cols)]
        matrix.append(row)
    return matrix

# Функция для подсчета среднего арифметического элементов над главной диагональю
def average_above_main_diagonal(matrix):
    if len(matrix) != len(matrix[0]):
        raise ValueError("Матрица не является квадратной")
    
    total = 0
    count = 0

    for i in range(len(matrix)):
        for j in range(i + 1, len(matrix)):
            total += matrix[i][j]
            count += 1

    if count == 0:
        return 0
    else:
        return total / count

# Функция для подсчета количества четных элементов под главной диагональю
def count_even_below_main_diagonal(matrix):
    if len(matrix) != len(matrix[0]):
        raise ValueError("Матрица не является квадратной")
    
    count = 0

    for i in range(len(matrix)):
        for j in range(i):
            if matrix[i][j] % 2 == 0:
                count += 1

    return count

try:
    rows = int(input("Введите количество строк матрицы: "))
    cols = int(input("Введите количество столбцов матрицы: "))
    min_value = int(input("Введите минимальное значение: "))
    max_value = int(input("Введите максимальное значение: "))

    matrix = create_matrix(rows, cols, min_value, max_value)
    print("Матрица:")
    for row in matrix:
        print(row)

    average = average_above_main_diagonal(matrix)
    even_count = count_even_below_main_diagonal(matrix)

    print(f"Среднее арифметическое элементов над главной диагональю: {average:.2f}")
    print(f"Количество четных элементов под главной диагональю: {even_count}")
except ValueError as e:
    print(f"Ошибка: {e}")

24.	 Напишите функцию для решения уравнений степени не выше второй (квадратные и линейные):
- если у функции три аргумента, их надо трактовать как a, b и c в уравнении ax 2 + bx + c = 0;
- если два — как коэффициенты b и c в уравнении bx + c = 0;
- если один — как коэффициент c в уравнении c = 0;
- если список коэффициентов пуст или коэффициентов больше трёх, то функция должна вернуть None.
Функция возвращает список, содержащий все корни уравнения (два, один или ни одного). Если корнем является любое значение x, функция возвращает список, содержащий символ «*» (["*"]).

25.	Задан список словарей: dl = {'a': 10, 'b': 20, 'c': 1}, {'a': 5, 'b': 10, 'z': 10}, {'a': 3, 'y': 7}. С помощью анонимной функции отсортировать словари по значению, содержащемуся по ключу 'a'.
Решение:
dl = [{'a': 10, 'b': 20, 'c': 1}, {'a': 5, 'b': 10, 'z': 10}, {'a': 3, 'y': 7}]

sorted_dl = sorted(dl, key=lambda x: x['a'])

print(sorted_dl)
